
-- generated by elm_rs


module Generated.Domain exposing (..)

import Dict exposing (Dict)
import Http
import Json.Decode
import Json.Encode
import Url.Builder


resultEncoder : (e -> Json.Encode.Value) -> (t -> Json.Encode.Value) -> (Result e t -> Json.Encode.Value)
resultEncoder errEncoder okEncoder enum =
    case enum of
        Ok inner ->
            Json.Encode.object [ ( "Ok", okEncoder inner ) ]
        Err inner ->
            Json.Encode.object [ ( "Err", errEncoder inner ) ]


resultDecoder : Json.Decode.Decoder e -> Json.Decode.Decoder t -> Json.Decode.Decoder (Result e t)
resultDecoder errDecoder okDecoder =
    Json.Decode.oneOf
        [ Json.Decode.map Ok (Json.Decode.field "Ok" okDecoder)
        , Json.Decode.map Err (Json.Decode.field "Err" errDecoder)
        ]


type alias GcdParameters =
    { n : Int
    , m : Int
    , other : Maybe (Int)
    }


gcdParametersEncoder : GcdParameters -> Json.Encode.Value
gcdParametersEncoder struct =
    Json.Encode.object
        [ ( "n", (Json.Encode.int) struct.n )
        , ( "m", (Json.Encode.int) struct.m )
        , ( "other", (Maybe.withDefault Json.Encode.null << Maybe.map (Json.Encode.int)) struct.other )
        ]


gcdParametersDecoder : Json.Decode.Decoder GcdParameters
gcdParametersDecoder =
    Json.Decode.succeed GcdParameters
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "n" (Json.Decode.int)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "m" (Json.Decode.int)))
        |> Json.Decode.andThen (\x -> Json.Decode.map x (Json.Decode.field "other" (Json.Decode.nullable (Json.Decode.int))))


